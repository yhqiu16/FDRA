digraph "CFG for 'array_add' function" {
	label="CFG for 'array_add' function";

	Node0x55982d083b70 [shape=record,label="{entry:\l  br label %for.body\l}"];
	Node0x55982d083b70 -> Node0x55982d08b0c0;
	Node0x55982d08b070 [shape=record,label="{for.cond.cleanup:                                 \l  ret void\l}"];
	Node0x55982d08b0c0 [shape=record,label="{for.body:                                         \l  %i.010 = phi i32 [ 0, %entry ], [ %add, %for.body ]\l  %call = tail call i32 bitcast (i32 (...)* @please_map_me to i32 ()*)() #4\l  %add = add nuw nsw i32 %i.010, 1\l  %arrayidx = getelementptr inbounds [20 x i32], [20 x i32]* @A, i32 0, i32\l... %add\l  %0 = load i32, i32* %arrayidx, align 4, !tbaa !3\l  %sub = add nsw i32 %i.010, -1\l  %arrayidx1 = getelementptr inbounds [20 x i32], [20 x i32]* @A, i32 0, i32\l... %sub\l  %1 = load i32, i32* %arrayidx1, align 4, !tbaa !3\l  %add2 = add nsw i32 %1, %0\l  %arrayidx4 = getelementptr inbounds [40 x [50 x i32]], [40 x [50 x i32]]*\l... @B, i32 0, i32 %i.010, i32 0\l  store i32 %add2, i32* %arrayidx4, align 4, !tbaa !3\l  %exitcond = icmp eq i32 %add, 20\l  br i1 %exitcond, label %for.cond.cleanup, label %for.body\l|{<s0>T|<s1>F}}"];
	Node0x55982d08b0c0:s0 -> Node0x55982d08b070;
	Node0x55982d08b0c0:s1 -> Node0x55982d08b0c0;
}
