#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include benchmark-specific header. */
#include "include/encoding.h"
#include "include/ISA.h"

#define TYPE int
#define NI 32
#define NJ 32
#define N NI*NJ
// ################################ conv2d_3x3 ##########################################
int conv2d_3x3_A[N] __attribute__((aligned(16)));
int conv2d_3x3_B[N] __attribute__((aligned(16)));
int conv2d_3x3_C[N] __attribute__((aligned(16)));

/*For 3x3 filter*/
#define c11 2
#define c12 -3
#define c21 5
#define c22 6
#define c13 4
#define c23 7
#define c31 -8
#define c32 -9
#define c33 10

__attribute__((noinline)) void conv2d_3x3()
{
	for (int i = 1; i < NI - 1; i++)
	{
		for (int j = 1; j < NJ - 1; j++)
		{
			/*For 3x3 filter*/
			conv2d_3x3_C[i * NJ + j] = c11 * conv2d_3x3_A[(i - 1) * NJ + (j - 1)] + c12 * conv2d_3x3_A[(i + 0) * NJ + (j - 1)] + c13 * conv2d_3x3_A[(i + 1) * NJ + (j - 1)] + c21 * conv2d_3x3_A[(i - 1) * NJ + (j + 0)] + c22 * conv2d_3x3_A[(i + 0) * NJ + (j + 0)] + c23 * conv2d_3x3_A[(i + 1) * NJ + (j + 0)] + c31 * conv2d_3x3_A[(i - 1) * NJ + (j + 1)] + c32 * conv2d_3x3_A[(i + 0) * NJ + (j + 1)] + c33 * conv2d_3x3_A[(i + 1) * NJ + (j + 1)];
		}
	}
}

// ################################ fir-unroll4 ##########################################
#define NTAPS 8
int fir_input[N] __attribute__((aligned(16)));
int fir_output[N] __attribute__((aligned(16)));
int fir_res[N] __attribute__((aligned(16)));
int coefficients[NTAPS] __attribute__((aligned(16))) = {
    025, 150, 375, -225, 050, 075, -300, 125};

__attribute__((noinline)) void fir() //(int input[], int output[], int coefficients[])
/*   input :           input sample array */
/*   output:           output sample array */
/*   coefficient:      coefficient array */
{
  int i, j;
  for (j = NTAPS-1; j < N; ++j)
  {
    int sum = 0;
    #pragma unroll 4
    for (i = 0; i < NTAPS; ++i)
    {
 #ifdef CGRA_COMPILER
       please_map_me();
 #endif
      sum += fir_input[j - i] * coefficients[i];
    }
    fir_res[j] = sum;
  }
}

// ################################ pedometer ##########################################
int acc_vector[N] __attribute__((aligned(16)));
int res_vector[N] __attribute__((aligned(16)));
int acceleration_x[N] __attribute__((aligned(16)));
int acceleration_y[N] __attribute__((aligned(16)));
int acceleration_z[N] __attribute__((aligned(16)));
int acc_avg_x[N] __attribute__((aligned(16)));
int acc_avg_y[N] __attribute__((aligned(16)));
int acc_avg_z[N] __attribute__((aligned(16)));

/* Main computational kernel. The whole function will be timed,
   including the call and return. */
__attribute__((noinline)) void pedometer()
{
	for (int i = 0; i < N; i++)
	{
		res_vector[i] = (acceleration_x[i] - acc_avg_x[i]) * (acceleration_x[i] - acc_avg_x[i]) + (acceleration_y[i] - acc_avg_y[i]) * (acceleration_y[i] - acc_avg_y[i]) + (acceleration_z[i] - acc_avg_z[i]) * (acceleration_z[i] - acc_avg_z[i]);
	}
}

// ################################ stencil2d ##########################################
#define f_N 9

TYPE filter[f_N] __attribute__((aligned(16)));
TYPE orig[NI * NJ] __attribute__((aligned(16)));
TYPE sol[NI * NJ] __attribute__((aligned(16)));
TYPE res[NI * NJ] __attribute__((aligned(16)));

__attribute__((noinline)) void stencil2d()
{
	int r, c, k1, k2;
	TYPE temp, mul;

	for (r = 0; r < NI - 2; r++)
	{
		for (c = 0; c < NJ - 2; c++)
		{
			temp = (TYPE)0;
			for (k1 = 0; k1 < 3; k1++)
			{
#pragma unroll
				for (k2 = 0; k2 < 3; k2++)
				{
					mul = filter[k1 * 3 + k2] * orig[(r + k1) * NJ + c + k2];
					temp += mul;
				}
			}
			res[(r * NJ) + c] = temp;
		}
	}
}

// ################################ gemm-unroll4 ##########################################
TYPE gemm_m1[N] __attribute__((aligned(16)));
TYPE gemm_m2[N] __attribute__((aligned(16)));
TYPE gemm_prod0[N] __attribute__((aligned(16)));
TYPE gemm_prod[N] __attribute__((aligned(16)));

__attribute__((noinline)) void gemm()
{
	int i, j, k;
	int k_col, i_col;
	TYPE mult;

outer:
	for (i = 0; i < NI; i++)
	{
	middle:
		for (j = 0; j < NJ; j++)
		{
			i_col = i * NJ;
			TYPE sum = 0;
#pragma unroll 4
			for (k = 0; k < NI; k++)
			{
				k_col = k * NJ;
				mult = gemm_m1[i_col + k] * gemm_m2[k_col + j];
				sum += mult;
			}
			gemm_prod0[i_col + j] = sum;
		}
	}
}


// ################################ fft ##########################################
TYPE XR0[N] __attribute__((aligned(16)));
TYPE XR1[N] __attribute__((aligned(16)));
TYPE XR2[N] __attribute__((aligned(16)));
TYPE XR3[N] __attribute__((aligned(16)));
TYPE XI0[N] __attribute__((aligned(16)));
TYPE XI1[N] __attribute__((aligned(16)));
TYPE XI2[N] __attribute__((aligned(16)));
TYPE XI3[N] __attribute__((aligned(16)));
TYPE YR0[N] __attribute__((aligned(16)));
TYPE YR1[N] __attribute__((aligned(16)));
TYPE YR2[N] __attribute__((aligned(16)));
TYPE YR3[N] __attribute__((aligned(16)));
TYPE YI0[N] __attribute__((aligned(16)));
TYPE YI1[N] __attribute__((aligned(16)));
TYPE YI2[N] __attribute__((aligned(16)));
TYPE YI3[N] __attribute__((aligned(16)));
TYPE ZR0[N] __attribute__((aligned(16)));
TYPE ZR1[N] __attribute__((aligned(16)));
TYPE ZR2[N] __attribute__((aligned(16)));
TYPE ZR3[N] __attribute__((aligned(16)));
TYPE ZI0[N] __attribute__((aligned(16)));
TYPE ZI1[N] __attribute__((aligned(16)));
TYPE ZI2[N] __attribute__((aligned(16)));
TYPE ZI3[N] __attribute__((aligned(16)));

#define cmplx_M_x(a_x, a_y, b_x, b_y) (a_x * b_x - a_y * b_y)
#define cmplx_M_y(a_x, a_y, b_x, b_y) (a_x * b_y + a_y * b_x)
#define cmplx_MUL_x(a_x, a_y, b_x, b_y) (a_x * b_x - a_y * b_y)
#define cmplx_MUL_y(a_x, a_y, b_x, b_y) (a_x * b_y + a_y * b_x)
#define cmplx_mul_x(a_x, a_y, b_x, b_y) (a_x * b_x - a_y * b_y)
#define cmplx_mul_y(a_x, a_y, b_x, b_y) (a_x * b_y + a_y * b_x)
#define cmplx_add_x(a_x, b_x) (a_x + b_x)
#define cmplx_add_y(a_y, b_y) (a_y + b_y)
#define cmplx_sub_x(a_x, b_x) (a_x - b_x)
#define cmplx_sub_y(a_y, b_y) (a_y - b_y)
#define cm_fl_mul_x(a_x, b) (b * a_x)
#define cm_fl_mul_y(a_y, b) (b * a_y)

#define FF2(a0_x, a0_y, a1_x, a1_y)     \
	{                                   \
		TYPE c0_x = a0_x;               \
		TYPE c0_y = a0_y;               \
		a0_x = cmplx_add_x(c0_x, a1_x); \
		a0_y = cmplx_add_y(c0_y, a1_y); \
		a1_x = cmplx_sub_x(c0_x, a1_x); \
		a1_y = cmplx_sub_y(c0_y, a1_y); \
	}

#define FFT4(a0_x, a0_y, a1_x, a1_y, a2_x, a2_y, a3_x, a3_y) \
	{                                                        \
		TYPE exp_1_44_x;                                     \
		TYPE exp_1_44_y;                                     \
		TYPE tmp;                                            \
		exp_1_44_x = 0;                                      \
		exp_1_44_y = -1;                                     \
		FF2(a0_x, a0_y, a2_x, a2_y);                         \
		FF2(a1_x, a1_y, a3_x, a3_y);                         \
		tmp = a3_x;                                          \
		a3_x = a3_x * exp_1_44_x - a3_y * exp_1_44_y;        \
		a3_y = tmp * exp_1_44_y - a3_y * exp_1_44_x;         \
		FF2(a0_x, a0_y, a1_x, a1_y);                         \
		FF2(a2_x, a2_y, a3_x, a3_y);                         \
	}

__attribute__((noinline)) void fft4()
{
	int i;
	for (i = 0; i < N; i++)
	{
		//    please_map_me();
		TYPE a0_x = XR0[i];
		TYPE a0_y = XI0[i];
		TYPE a1_x = XR1[i];
		TYPE a1_y = XI1[i];
		TYPE a2_x = XR2[i];
		TYPE a2_y = XI2[i];
		TYPE a3_x = XR3[i];
		TYPE a3_y = XI3[i];
		FFT4(a0_x, a0_y, a1_x, a1_y, a2_x, a2_y, a3_x, a3_y);
		ZR0[i] = a0_x;
		ZI0[i] = a0_y;
		ZR1[i] = a1_x;
		ZI1[i] = a1_y;
		ZR2[i] = a2_x;
		ZI2[i] = a2_y;
		ZR3[i] = a3_x;
		ZI3[i] = a3_y;
	}
}

// ################################ knn ##########################################
#define nAtoms 64
#define maxNeighbors 16
// LJ coefficients
#define lj1 1 // 1.5
#define lj2 2 // 2.0

TYPE force_x[nAtoms] __attribute__((aligned(16)));
TYPE force_y[nAtoms] __attribute__((aligned(16)));
TYPE force_z[nAtoms] __attribute__((aligned(16)));
TYPE force_x0[nAtoms] __attribute__((aligned(16)));
TYPE force_y0[nAtoms] __attribute__((aligned(16)));
TYPE force_z0[nAtoms] __attribute__((aligned(16)));
TYPE position_x[nAtoms] __attribute__((aligned(16)));
TYPE position_y[nAtoms] __attribute__((aligned(16)));
TYPE position_z[nAtoms] __attribute__((aligned(16)));
unsigned NL[nAtoms * maxNeighbors] __attribute__((aligned(16)));

__attribute__((noinline)) void md()
{
	TYPE delx, dely, delz, r2inv;
	TYPE r6inv, potential, force, j_x, j_y, j_z;
	TYPE i_x, i_y, i_z, fx, fy, fz;

	int32_t i, j, jidx;

loop_i:
	for (i = 0; i < nAtoms; i++)
	{
		i_x = position_x[i];
		i_y = position_y[i];
		i_z = position_z[i];
		fx = 0;
		fy = 0;
		fz = 0;
	loop_j:
		for (j = 0; j < maxNeighbors; j++)
		{
			//	please_map_me();
			// Get neighbor
			jidx = NL[i * maxNeighbors + j];
			// Look up x,y,z positions
			j_x = position_x[jidx];
			j_y = position_y[jidx];
			j_z = position_z[jidx];
			// Calc distance
			delx = i_x - j_x;
			dely = i_y - j_y;
			delz = i_z - j_z;
			r2inv = 10 / (delx * delx + dely * dely + delz * delz); // r2inv = 1.0/( delx*delx + dely*dely + delz*delz );
			// Assume no cutoff and aways account for all nodes in area
			r6inv = r2inv * r2inv * r2inv;
			potential = r6inv * (lj1 * r6inv - lj2 * 1000);
			// Sum changes in force
			force = r2inv * potential;
			/*potential = r6inv/100000000*(lj1*r6inv - lj2*1000000000);
			// Sum changes in force
			force = r2inv*potential/10000000000;*/
			fx += delx * force;
			fy += dely * force;
			fz += delz * force;
		}
		// Update forces after all neighbors accounted for.
		force_x0[i] = fx;
		force_y0[i] = fy;
		force_z0[i] = fz;
		// printf("dF=%lf,%lf,%lf\n", fx, fy, fz);
	}
}


void conv2d_3x3_cgra_execute(void **din_addr, void **dout_addr)
{
	static unsigned short cin[83][3] __attribute__((aligned(16))) = {
		{0x2041, 0x7800, 0x0010},
		{0x00c0, 0x00f0, 0x0011},
		{0x0000, 0x0100, 0x0012},
		{0x0000, 0x0000, 0x0013},
		{0x2002, 0x7800, 0x0014},
		{0x00c0, 0x00f0, 0x0015},
		{0x0000, 0x0100, 0x0016},
		{0x0000, 0x0000, 0x0017},
		{0x2842, 0x7800, 0x001c},
		{0x00c0, 0x00f0, 0x001d},
		{0x0000, 0x0100, 0x001e},
		{0x0000, 0x0000, 0x001f},
		{0x3001, 0x7800, 0x0020},
		{0x00c0, 0x00f0, 0x0021},
		{0x0000, 0x9900, 0x0022},
		{0x0000, 0x0000, 0x0023},
		{0x0000, 0x0004, 0x0038},
		{0x0800, 0x0000, 0x003c},
		{0x0030, 0x0000, 0x0044},
		{0xfff8, 0xffff, 0x0058},
		{0x0803, 0x0000, 0x0059},
		{0x0007, 0x0000, 0x005c},
		{0x0403, 0x0000, 0x005d},
		{0x3281, 0x0000, 0x0061},
		{0x6f01, 0x0000, 0x0065},
		{0x000a, 0x0000, 0x0068},
		{0x0413, 0x0000, 0x0069},
		{0x0000, 0x0040, 0x0084},
		{0x12c1, 0x0000, 0x0088},
		{0x0400, 0x0000, 0x008c},
		{0x8c81, 0x0000, 0x00a1},
		{0x8d01, 0x0000, 0x00a5},
		{0x2a01, 0x0000, 0x00a9},
		{0x8581, 0x0000, 0x00ad},
		{0x2701, 0x0000, 0x00b1},
		{0x1010, 0x0000, 0x00c4},
		{0x0000, 0x0000, 0x00c8},
		{0x0000, 0x0000, 0x00cc},
		{0x0000, 0x0000, 0x00d0},
		{0x0000, 0x0000, 0x00d4},
		{0x0001, 0x0000, 0x00e0},
		{0x1005, 0x0000, 0x00e1},
		{0x6801, 0x0000, 0x00e5},
		{0xfffd, 0xffff, 0x00e8},
		{0x0c03, 0x0000, 0x00e9},
		{0x0002, 0x0000, 0x00ec},
		{0x0c05, 0x0000, 0x00ed},
		{0x0005, 0x0000, 0x00f0},
		{0x1003, 0x0000, 0x00f1},
		{0xfff7, 0xffff, 0x00f4},
		{0x0c03, 0x0000, 0x00f5},
		{0x0006, 0x0000, 0x00f8},
		{0x0c03, 0x0000, 0x00f9},
		{0x0001, 0x0000, 0x0108},
		{0x0010, 0x0000, 0x010c},
		{0x0010, 0x0000, 0x0110},
		{0x0000, 0x0010, 0x0114},
		{0x0021, 0x0000, 0x0118},
		{0x0010, 0x0000, 0x011c},
		{0x2000, 0x7800, 0x0128},
		{0x00c0, 0x00f0, 0x0129},
		{0x0000, 0x0100, 0x012a},
		{0x0000, 0x0000, 0x012b},
		{0x2820, 0x7800, 0x012c},
		{0x00c0, 0x00f0, 0x012d},
		{0x0000, 0x0100, 0x012e},
		{0x0000, 0x0000, 0x012f},
		{0x3040, 0x7800, 0x0130},
		{0x00c0, 0x00f0, 0x0131},
		{0x0000, 0x0100, 0x0132},
		{0x0000, 0x0000, 0x0133},
		{0x3022, 0x7800, 0x0134},
		{0x00c0, 0x00f0, 0x0135},
		{0x0000, 0x0100, 0x0136},
		{0x0000, 0x0000, 0x0137},
		{0x2001, 0x7800, 0x0138},
		{0x00c0, 0x00f0, 0x0139},
		{0x0000, 0x0100, 0x013a},
		{0x0000, 0x0000, 0x013b},
		{0x2821, 0x7800, 0x013c},
		{0x00c0, 0x00f0, 0x013d},
		{0x0000, 0x0100, 0x013e},
		{0x0000, 0x0000, 0x013f},
	};

	load_cfg((void*)cin, 0x20000, 498, 0, 0);
	load_data(din_addr[0], 0x10000, 4096, 1, 0, 0);
	load_data(din_addr[1], 0x12000, 4096, 1, 0, 0);
	load_data(din_addr[2], 0x14000, 4096, 1, 0, 0);
	load_data(din_addr[3], 0x18000, 4096, 1, 0, 0);
	load_data(din_addr[4], 0x1a000, 4096, 1, 0, 0);
	load_data(din_addr[5], 0x0, 4096, 1, 0, 0);
	load_data(din_addr[6], 0x8000, 4096, 1, 0, 0);
	load_data(din_addr[7], 0x1c000, 4096, 1, 0, 0);
	load_data(din_addr[8], 0xa000, 4096, 0, 0, 0);
	config(0x0, 83, 0, 0);
	execute(0x7ed8, 0, 0);
	store(dout_addr[0], 0xc000, 3836, 0, 0);
}


void fir_cgra_execute(void **din_addr, void **dout_addr)
{
	static unsigned short cin[59][3] __attribute__((aligned(16))) = {
		{0x8804, 0x0bff, 0x0004},
		{0x0140, 0x1fc8, 0x0005},
		{0x0000, 0x0100, 0x0006},
		{0x0000, 0x0000, 0x0007},
		{0x9803, 0x0800, 0x0008},
		{0xff00, 0x1fcf, 0x0009},
		{0x0000, 0x0100, 0x000a},
		{0x0000, 0x0000, 0x000b},
		{0x8407, 0x0bff, 0x000c},
		{0x0140, 0x1fc8, 0x000d},
		{0x0000, 0x0100, 0x000e},
		{0x0000, 0x0000, 0x000f},
		{0x9002, 0x0800, 0x0010},
		{0xff00, 0x1fcf, 0x0011},
		{0x0000, 0x0100, 0x0012},
		{0x0000, 0x0000, 0x0013},
		{0x8c05, 0x0bff, 0x0014},
		{0x0140, 0x1fc8, 0x0015},
		{0x0000, 0x0100, 0x0016},
		{0x0000, 0x0000, 0x0017},
		{0x8406, 0x0bff, 0x0018},
		{0x0140, 0x1fc8, 0x0019},
		{0x0000, 0x0100, 0x001a},
		{0x0000, 0x0000, 0x001b},
		{0x0100, 0x0000, 0x002c},
		{0x1000, 0x0000, 0x0034},
		{0x0400, 0x0030, 0x0038},
		{0x0000, 0x0000, 0x003c},
		{0x2403, 0x0000, 0x0051},
		{0x6881, 0x0000, 0x0055},
		{0x3083, 0x0000, 0x0059},
		{0x2403, 0x0000, 0x005d},
		{0x0400, 0x0000, 0x0078},
		{0x1000, 0x0040, 0x007c},
		{0x8903, 0x0000, 0x0080},
		{0x2811, 0x0000, 0x009d},
		{0x4c03, 0x0000, 0x00a1},
		{0x2431, 0x0000, 0x00a5},
		{0x0000, 0x0100, 0x00c0},
		{0x0020, 0x0000, 0x00c4},
		{0x0100, 0x0020, 0x00c8},
		{0x040d, 0x0000, 0x00ed},
		{0x0000, 0x8001, 0x00ee},
		{0x4008, 0x00fe, 0x00ef},
		{0x0000, 0x0004, 0x0108},
		{0x0000, 0x0000, 0x0110},
		{0x0000, 0x0000, 0x0114},
		{0x8401, 0x0800, 0x0128},
		{0xff00, 0x1fcf, 0x0129},
		{0x0000, 0x0100, 0x012a},
		{0x0000, 0x0000, 0x012b},
		{0x8400, 0x0800, 0x0134},
		{0xff00, 0x1fcf, 0x0135},
		{0x0000, 0x0100, 0x0136},
		{0x0000, 0x0000, 0x0137},
		{0x0803, 0x0800, 0x0138},
		{0x0040, 0x1fc8, 0x0139},
		{0x0000, 0x9300, 0x013a},
		{0x0000, 0x0000, 0x013b},
	};

	load_cfg((void*)cin, 0x20200, 354, 1, 0);
	load_data(din_addr[0], 0x19000, 32, 1, 1, 0);
	load_data(din_addr[1], 0x11000, 32, 1, 1, 0);
	load_data(din_addr[2], 0x4000, 32, 1, 1, 0);
	load_data(din_addr[3], 0x6000, 32, 0, 1, 0);
	load_data(din_addr[4], 0x1000, 4096, 1, 1, 0);
	load_data(din_addr[5], 0x9000, 4096, 1, 1, 0);
	load_data(din_addr[6], 0xb000, 4096, 1, 1, 0);
	load_data(din_addr[7], 0x2000, 4096, 0, 1, 0);
	config(0x20, 59, 1, 0);
	execute(0x323f, 1, 0);
	store(dout_addr[0], 0x1a000, 4080, 1, 0);
}


void pedometer_cgra_execute(void **din_addr, void **dout_addr)
{
	static unsigned short cin[46][3] __attribute__((aligned(16))) = {
		{0x2000, 0x0000, 0x0004},
		{0x0010, 0x0000, 0x0005},
		{0x0000, 0x0100, 0x0006},
		{0x0000, 0x0000, 0x0007},
		{0x2c00, 0x0000, 0x0008},
		{0x0010, 0x0000, 0x0009},
		{0x0000, 0x0100, 0x000a},
		{0x0000, 0x0000, 0x000b},
		{0x3008, 0x0000, 0x000c},
		{0x0010, 0x0000, 0x000d},
		{0x0000, 0x0100, 0x000e},
		{0x0000, 0x0000, 0x000f},
		{0x3808, 0x0000, 0x0010},
		{0x0010, 0x0000, 0x0011},
		{0x0000, 0x0100, 0x0012},
		{0x0000, 0x0000, 0x0013},
		{0x0000, 0x0000, 0x002c},
		{0x0000, 0x0018, 0x0030},
		{0x0800, 0x0000, 0x0034},
		{0x2802, 0x0000, 0x0055},
		{0x3002, 0x0000, 0x0059},
		{0x0300, 0x0000, 0x0078},
		{0x1003, 0x0000, 0x0080},
		{0x4803, 0x0000, 0x0099},
		{0x6412, 0x0000, 0x009d},
		{0x8801, 0x0000, 0x00a1},
		{0x2403, 0x0000, 0x00a5},
		{0x00c0, 0x0000, 0x00c0},
		{0x0000, 0x0000, 0x00c4},
		{0x0004, 0x0020, 0x00c8},
		{0x2901, 0x0000, 0x00e5},
		{0x2403, 0x0000, 0x00e9},
		{0x0000, 0x0000, 0x0108},
		{0x0000, 0x0000, 0x0110},
		{0x2800, 0x0000, 0x0128},
		{0x0010, 0x0000, 0x0129},
		{0x0000, 0x9100, 0x012a},
		{0x0080, 0x0000, 0x012b},
		{0x2000, 0x0000, 0x012c},
		{0x0010, 0x0000, 0x012d},
		{0x0000, 0x0100, 0x012e},
		{0x0000, 0x0000, 0x012f},
		{0x2000, 0x0000, 0x0134},
		{0x0010, 0x0000, 0x0135},
		{0x0000, 0x0100, 0x0136},
		{0x0000, 0x0000, 0x0137},
	};

	load_cfg((void*)cin, 0x20370, 276, 2, 0);
	load_data(din_addr[0], 0x10000, 4096, 0, 2, 0);
	load_data(din_addr[1], 0x0, 4096, 0, 2, 0);
	load_data(din_addr[2], 0x3000, 4096, 0, 2, 0);
	load_data(din_addr[3], 0x4020, 4096, 0, 2, 0);
	load_data(din_addr[4], 0x18000, 4096, 0, 2, 0);
	load_data(din_addr[5], 0x6020, 4096, 0, 2, 0);
	config(0x37, 46, 2, 0);
	execute(0x160f, 2, 0);
	store(dout_addr[0], 0x12000, 4096, 2, 0);
}


void stencil2d_cgra_execute(void **din_addr, void **dout_addr)
{
	static unsigned short cin[46][3] __attribute__((aligned(16))) = {
		{0x0400, 0x0c04, 0x000c},
		{0xf040, 0x80f7, 0x000d},
		{0xefe1, 0x0101, 0x000e},
		{0x0000, 0x0000, 0x000f},
		{0x0800, 0x0c00, 0x0010},
		{0x0040, 0x80f0, 0x0011},
		{0xe001, 0x8f01, 0x0012},
		{0x0000, 0x0000, 0x0013},
		{0x6000, 0x0c00, 0x0014},
		{0xfe80, 0x00f7, 0x0015},
		{0xeffd, 0x0101, 0x0016},
		{0x0000, 0x0000, 0x0017},
		{0x0030, 0x0000, 0x0034},
		{0x0000, 0x0000, 0x0038},
		{0x4403, 0x0000, 0x0059},
		{0x0000, 0x0000, 0x007c},
		{0x0000, 0x0000, 0x0080},
		{0x100d, 0x0000, 0x00a1},
		{0x0000, 0x6001, 0x00a2},
		{0x000c, 0x00e1, 0x00a3},
		{0x8401, 0x0000, 0x00a5},
		{0x0001, 0x0000, 0x00c8},
		{0x0000, 0x0000, 0x00cc},
		{0x8c03, 0x0000, 0x00e5},
		{0x4c11, 0x0000, 0x00e9},
		{0x8c03, 0x0000, 0x00f1},
		{0x0010, 0x0000, 0x0108},
		{0x0000, 0x0000, 0x010c},
		{0x0010, 0x0000, 0x0114},
		{0x0000, 0x0000, 0x0118},
		{0x0401, 0x0c04, 0x0128},
		{0xf040, 0x80f7, 0x0129},
		{0xefe1, 0x0101, 0x012a},
		{0x0000, 0x0000, 0x012b},
		{0x7001, 0x0c00, 0x0130},
		{0xfe80, 0x00f7, 0x0131},
		{0xeffd, 0x0101, 0x0132},
		{0x0000, 0x0000, 0x0133},
		{0x0402, 0x0c04, 0x0134},
		{0xf040, 0x80f7, 0x0135},
		{0xefe1, 0x0101, 0x0136},
		{0x0000, 0x0000, 0x0137},
		{0x7002, 0x0c00, 0x013c},
		{0xfe80, 0x00f7, 0x013d},
		{0xeffd, 0x0101, 0x013e},
		{0x0000, 0x0000, 0x013f},
	};

	load_cfg((void*)cin, 0x20490, 276, 3, 0);
	load_data(din_addr[0], 0x8000, 36, 1, 3, 0);
	load_data(din_addr[1], 0x14000, 36, 1, 3, 0);
	load_data(din_addr[2], 0x1c000, 36, 0, 3, 0);
	load_data(din_addr[3], 0x1000, 4096, 1, 3, 0);
	load_data(din_addr[4], 0x11000, 4096, 1, 3, 0);
	load_data(din_addr[5], 0x19000, 4096, 0, 3, 0);
	config(0x49, 46, 3, 0);
	execute(0x5a1c, 3, 0);
	store(dout_addr[0], 0x2000, 3832, 3, 0);
}


void gemm_cgra_execute(void **din_addr, void **dout_addr)
{
	static unsigned short cin[60][3] __attribute__((aligned(16))) = {
		{0x1060, 0x2010, 0x0008},
		{0x2040, 0x8107, 0x0009},
		{0x0e30, 0x0102, 0x000a},
		{0x0000, 0x0000, 0x000b},
		{0x0020, 0x2010, 0x000c},
		{0x2040, 0x8107, 0x000d},
		{0x0e30, 0x0102, 0x000e},
		{0x0000, 0x0000, 0x000f},
		{0x0bc0, 0x2000, 0x0010},
		{0x0040, 0x8100, 0x0011},
		{0x0000, 0x9302, 0x0012},
		{0x0000, 0x0000, 0x0013},
		{0x800c, 0x2000, 0x0014},
		{0xf900, 0x0107, 0x0015},
		{0x0002, 0x0102, 0x0016},
		{0x0000, 0x0000, 0x0017},
		{0x9003, 0x2000, 0x0018},
		{0xf900, 0x0107, 0x0019},
		{0x0002, 0x0102, 0x001a},
		{0x0000, 0x0000, 0x001b},
		{0x8801, 0x2000, 0x001c},
		{0xf900, 0x0107, 0x001d},
		{0x0002, 0x0102, 0x001e},
		{0x0000, 0x0000, 0x001f},
		{0x0000, 0x0000, 0x0030},
		{0x8030, 0x0000, 0x0034},
		{0x1200, 0x0012, 0x0038},
		{0x8000, 0x0000, 0x003c},
		{0x0000, 0x0000, 0x0040},
		{0x4413, 0x0000, 0x0055},
		{0x8811, 0x0000, 0x0059},
		{0x4483, 0x0000, 0x005d},
		{0x0000, 0x0208, 0x007c},
		{0x1c04, 0x0000, 0x0080},
		{0x100d, 0x0000, 0x009d},
		{0x0000, 0x8001, 0x009e},
		{0x0020, 0x0100, 0x009f},
		{0x2811, 0x0000, 0x00a1},
		{0x3003, 0x0000, 0x00a5},
		{0x0c00, 0x0000, 0x00c4},
		{0x3000, 0x0000, 0x00c8},
		{0x0003, 0x0001, 0x00cc},
		{0x2811, 0x0000, 0x00e9},
		{0x7013, 0x0000, 0x00f1},
		{0x0000, 0x0010, 0x0110},
		{0x0080, 0x0000, 0x0114},
		{0x0002, 0x0000, 0x0118},
		{0x0000, 0x0001, 0x011c},
		{0x8002, 0x2000, 0x0130},
		{0xf900, 0x0107, 0x0131},
		{0x0002, 0x0102, 0x0132},
		{0x0000, 0x0000, 0x0133},
		{0x0000, 0x2010, 0x0138},
		{0x2040, 0x8107, 0x0139},
		{0x0e30, 0x0102, 0x013a},
		{0x0000, 0x0000, 0x013b},
		{0x0840, 0x2010, 0x0140},
		{0x2040, 0x8107, 0x0141},
		{0x0e30, 0x0102, 0x0142},
		{0x0000, 0x0000, 0x0143},
	};

	load_cfg((void*)cin, 0x205b0, 360, 4, 0);
	load_data(din_addr[0], 0x8030, 4096, 1, 4, 0);
	load_data(din_addr[1], 0xa000, 4096, 1, 4, 0);
	load_data(din_addr[2], 0x10000, 4096, 1, 4, 0);
	load_data(din_addr[3], 0xc000, 4096, 0, 4, 0);
	load_data(din_addr[4], 0x18000, 4096, 1, 4, 0);
	load_data(din_addr[5], 0x0, 4096, 1, 4, 0);
	load_data(din_addr[6], 0x1a000, 4096, 1, 4, 0);
	load_data(din_addr[7], 0x4000, 4096, 0, 4, 0);
	config(0x5b, 60, 4, 0);
	execute(0xa87e, 4, 0);
	store(dout_addr[0], 0x2f00, 4096, 4, 0);
}


void fft_cgra_execute(void **din_addr, void **dout_addr)
{
	static unsigned short cin[106][3] __attribute__((aligned(16))) = {
		{0x3800, 0x0000, 0x0004},
		{0x0010, 0x0000, 0x0005},
		{0x0000, 0x8f00, 0x0006},
		{0x0080, 0x0000, 0x0007},
		{0x2800, 0x0000, 0x0008},
		{0x0010, 0x0000, 0x0009},
		{0x0000, 0x8b00, 0x000a},
		{0x0080, 0x0000, 0x000b},
		{0x3400, 0x0000, 0x000c},
		{0x0010, 0x0000, 0x000d},
		{0x0000, 0x0100, 0x000e},
		{0x0000, 0x0000, 0x000f},
		{0x2400, 0x0000, 0x0010},
		{0x0010, 0x0000, 0x0011},
		{0x0000, 0x0100, 0x0012},
		{0x0000, 0x0000, 0x0013},
		{0x2c00, 0x0000, 0x0014},
		{0x0010, 0x0000, 0x0015},
		{0x0000, 0x0100, 0x0016},
		{0x0000, 0x0000, 0x0017},
		{0x3400, 0x0000, 0x0018},
		{0x0010, 0x0000, 0x0019},
		{0x0000, 0x0100, 0x001a},
		{0x0000, 0x0000, 0x001b},
		{0x3800, 0x0000, 0x001c},
		{0x0010, 0x0000, 0x001d},
		{0x0000, 0x0100, 0x001e},
		{0x0000, 0x0000, 0x001f},
		{0x2000, 0x0000, 0x0020},
		{0x0010, 0x0000, 0x0021},
		{0x0000, 0x8d00, 0x0022},
		{0x0000, 0x0000, 0x0023},
		{0x0002, 0x0000, 0x002c},
		{0x0000, 0x0013, 0x0030},
		{0x8000, 0x0000, 0x0034},
		{0x1000, 0x0011, 0x0038},
		{0x2400, 0x0018, 0x003c},
		{0x0600, 0x0004, 0x0040},
		{0x0830, 0x0000, 0x0044},
		{0x4c01, 0x0000, 0x0055},
		{0x6812, 0x0000, 0x0059},
		{0x2801, 0x0000, 0x005d},
		{0x2c82, 0x0000, 0x0061},
		{0x2482, 0x0000, 0x0065},
		{0x2c02, 0x0000, 0x0069},
		{0x2010, 0x0640, 0x0078},
		{0x0080, 0x0200, 0x007c},
		{0x2000, 0x0600, 0x0080},
		{0x1330, 0x0000, 0x0084},
		{0x0400, 0x0000, 0x0088},
		{0x0000, 0x0208, 0x008c},
		{0x6801, 0x0000, 0x0099},
		{0x7002, 0x0000, 0x009d},
		{0x6801, 0x0000, 0x00a1},
		{0x6881, 0x0000, 0x00a5},
		{0x6481, 0x0000, 0x00a9},
		{0x2401, 0x0000, 0x00ad},
		{0x00c0, 0x0000, 0x00bc},
		{0x2040, 0x0000, 0x00c0},
		{0x40c0, 0x0600, 0x00c4},
		{0x8000, 0x0000, 0x00c8},
		{0x00c0, 0x0020, 0x00cc},
		{0x0000, 0x0600, 0x00d4},
		{0x6882, 0x0000, 0x00e1},
		{0x4c01, 0x0000, 0x00e5},
		{0x5012, 0x0000, 0x00e9},
		{0x4412, 0x0000, 0x00ed},
		{0x0040, 0x0004, 0x0104},
		{0x0000, 0x0000, 0x0108},
		{0x2000, 0x0000, 0x010c},
		{0x0001, 0x0000, 0x0110},
		{0x0300, 0x0004, 0x0114},
		{0x0200, 0x0000, 0x0118},
		{0x0300, 0x0000, 0x011c},
		{0x2800, 0x0000, 0x0124},
		{0x0010, 0x0000, 0x0125},
		{0x0000, 0x0100, 0x0126},
		{0x0000, 0x0000, 0x0127},
		{0x3000, 0x0000, 0x0128},
		{0x0010, 0x0000, 0x0129},
		{0x0000, 0x8d00, 0x012a},
		{0x0080, 0x0000, 0x012b},
		{0x3800, 0x0000, 0x012c},
		{0x0010, 0x0000, 0x012d},
		{0x0000, 0x8f00, 0x012e},
		{0x0080, 0x0000, 0x012f},
		{0x2400, 0x0000, 0x0130},
		{0x0010, 0x0000, 0x0131},
		{0x0000, 0x0100, 0x0132},
		{0x0000, 0x0000, 0x0133},
		{0x2400, 0x0000, 0x0134},
		{0x0010, 0x0000, 0x0135},
		{0x0000, 0x0100, 0x0136},
		{0x0000, 0x0000, 0x0137},
		{0x2800, 0x0000, 0x0138},
		{0x0010, 0x0000, 0x0139},
		{0x0000, 0x8f00, 0x013a},
		{0x0000, 0x0000, 0x013b},
		{0x3000, 0x0000, 0x013c},
		{0x0010, 0x0000, 0x013d},
		{0x0000, 0x8d00, 0x013e},
		{0x0000, 0x0000, 0x013f},
		{0x3800, 0x0000, 0x0140},
		{0x0010, 0x0000, 0x0141},
		{0x0000, 0x8f00, 0x0142},
		{0x0000, 0x0000, 0x0143},
	};

	load_cfg((void*)cin, 0x20000, 636, 5, 0);
	load_data(din_addr[0], 0x11000, 4096, 0, 5, 0);
	load_data(din_addr[1], 0x19000, 4096, 0, 5, 0);
	load_data(din_addr[2], 0xb000, 4096, 0, 5, 0);
	load_data(din_addr[3], 0xd000, 4096, 0, 5, 0);
	load_data(din_addr[4], 0x1000, 4096, 0, 5, 0);
	load_data(din_addr[5], 0x12000, 4096, 0, 5, 0);
	load_data(din_addr[6], 0xe000, 4096, 0, 5, 0);
	load_data(din_addr[7], 0x5000, 4096, 0, 5, 0);
	config(0x0, 106, 5, 0);
	execute(0xffff, 5, 1);
	store(dout_addr[0], 0x2000, 4096, 5, 0);
	store(dout_addr[1], 0x1a000, 4096, 5, 0);
	store(dout_addr[2], 0x16000, 4096, 5, 0);
	store(dout_addr[3], 0x1c000, 4096, 5, 0);
	store(dout_addr[4], 0x8000, 4096, 5, 0);
	store(dout_addr[5], 0x14000, 4096, 5, 0);
	store(dout_addr[6], 0x1e000, 4096, 5, 0);
	store(dout_addr[7], 0x6000, 4096, 5, 0);
}


void knn_cgra_execute(void **din_addr, void **dout_addr)
{
	static unsigned short cin[104][3] __attribute__((aligned(16))) = {
		{0x0000, 0x0000, 0x0008},
		{0x0010, 0x0000, 0x0009},
		{0x0000, 0x0900, 0x000a},
		{0x0001, 0x0000, 0x000b},
		{0x1000, 0x4000, 0x000c},
		{0x0040, 0x0200, 0x000d},
		{0x0000, 0x0100, 0x000e},
		{0x0000, 0x0000, 0x000f},
		{0x0400, 0x4000, 0x001c},
		{0x0040, 0x0200, 0x001d},
		{0x0000, 0xa500, 0x001e},
		{0x0080, 0x0000, 0x001f},
		{0x0800, 0x4000, 0x0020},
		{0x0040, 0x0200, 0x0021},
		{0x0000, 0xa500, 0x0022},
		{0x0080, 0x0000, 0x0023},
		{0x0430, 0x0000, 0x002c},
		{0x0000, 0x0004, 0x0030},
		{0x0000, 0x0008, 0x0034},
		{0x0000, 0x0008, 0x0038},
		{0x0000, 0x0008, 0x003c},
		{0x0800, 0x0000, 0x0040},
		{0x0003, 0x0000, 0x0044},
		{0x0000, 0x0000, 0x0048},
		{0x2842, 0x0000, 0x0051},
		{0x6c03, 0x0000, 0x0055},
		{0x6c81, 0x0000, 0x0059},
		{0x000a, 0x0000, 0x005c},
		{0x6004, 0x0000, 0x005d},
		{0x6d03, 0x0000, 0x0061},
		{0x3303, 0x0000, 0x0065},
		{0x0c0d, 0x0000, 0x0069},
		{0x0000, 0x1001, 0x006a},
		{0x0041, 0x0010, 0x006b},
		{0x0000, 0x0040, 0x0074},
		{0x0800, 0x0000, 0x0078},
		{0x0010, 0x0000, 0x007c},
		{0x0400, 0x0000, 0x0080},
		{0x0010, 0x0000, 0x0084},
		{0x1000, 0x0000, 0x0088},
		{0x0001, 0x0000, 0x008c},
		{0x9003, 0x0000, 0x0095},
		{0x0004, 0x0000, 0x0098},
		{0x0c03, 0x0000, 0x0099},
		{0x3001, 0x0000, 0x009d},
		{0x4803, 0x0000, 0x00a1},
		{0x2c83, 0x0000, 0x00a5},
		{0x6b03, 0x0000, 0x00a9},
		{0x6403, 0x0000, 0x00ad},
		{0x100d, 0x0000, 0x00b1},
		{0x0000, 0x1001, 0x00b2},
		{0x0041, 0x0010, 0x00b3},
		{0x0035, 0x0040, 0x00bc},
		{0x0000, 0x0080, 0x00c0},
		{0x0002, 0x0080, 0x00c4},
		{0x0000, 0x0081, 0x00c8},
		{0x0080, 0x0000, 0x00cc},
		{0x0040, 0x0000, 0x00d0},
		{0x0000, 0x0000, 0x00d4},
		{0x0000, 0x0000, 0x00d8},
		{0x9022, 0x0000, 0x00dd},
		{0x0004, 0x0000, 0x00e0},
		{0x1003, 0x0000, 0x00e1},
		{0x0004, 0x0000, 0x00e4},
		{0x0c03, 0x0000, 0x00e5},
		{0x7042, 0x0000, 0x00e9},
		{0x6c03, 0x0000, 0x00ed},
		{0xf830, 0xffff, 0x00f0},
		{0x0401, 0x0000, 0x00f1},
		{0x040d, 0x0000, 0x00f5},
		{0x0000, 0x1001, 0x00f6},
		{0x0041, 0x0010, 0x00f7},
		{0x6703, 0x0000, 0x00f9},
		{0x0006, 0x0000, 0x0104},
		{0x0111, 0x0003, 0x0108},
		{0x0040, 0x0003, 0x010c},
		{0x0001, 0x0001, 0x0110},
		{0x0000, 0x0020, 0x0114},
		{0x0000, 0x0020, 0x0118},
		{0x0080, 0x0000, 0x011c},
		{0x0c00, 0x0000, 0x0124},
		{0x0010, 0x0000, 0x0125},
		{0x0000, 0x0900, 0x0126},
		{0x0081, 0x0000, 0x0127},
		{0x2000, 0x4000, 0x0128},
		{0x0040, 0x0200, 0x0129},
		{0x0000, 0x0100, 0x012a},
		{0x0000, 0x0000, 0x012b},
		{0x1000, 0x0000, 0x012c},
		{0x0010, 0x0000, 0x012d},
		{0x0000, 0x0900, 0x012e},
		{0x0001, 0x0000, 0x012f},
		{0x1800, 0x4000, 0x0130},
		{0x0040, 0x0200, 0x0131},
		{0x0000, 0x0100, 0x0132},
		{0x0000, 0x0000, 0x0133},
		{0x0000, 0x4000, 0x0134},
		{0x0040, 0x0200, 0x0135},
		{0x0000, 0x0100, 0x0136},
		{0x0000, 0x0000, 0x0137},
		{0x0c00, 0x4000, 0x0140},
		{0x0040, 0x0200, 0x0141},
		{0x0000, 0xa500, 0x0142},
		{0x0000, 0x0000, 0x0143},
	};

	load_cfg((void*)cin, 0x20280, 624, 6, 0);
	load_data(din_addr[0], 0x10000, 4096, 0, 6, 0);
	load_data(din_addr[1], 0x13000, 256, 1, 6, 0);
	load_data(din_addr[2], 0x18000, 256, 0, 6, 0);
	load_data(din_addr[3], 0x0, 256, 1, 6, 0);
	load_data(din_addr[4], 0x4000, 256, 0, 6, 0);
	load_data(din_addr[5], 0x14000, 256, 1, 6, 1);
	load_data(din_addr[6], 0x16000, 256, 0, 6, 1);
	config(0x28, 104, 6, 0);
	execute(0x9fc6, 6, 0);
	store(dout_addr[0], 0x1b000, 256, 6, 0);
	store(dout_addr[1], 0x9000, 256, 6, 0);
	store(dout_addr[2], 0xa000, 256, 6, 0);
}

///* Array initialization. */
void init_array()
{
	int i, j;
	for (i = 0; i < nAtoms; i++)
	{
		position_x[i] = i;
		position_y[i] = i + 1;
		position_z[i] = i + 2;
	}
	for (i = 0; i < nAtoms; i++)
	{
		for (j = 0; j < maxNeighbors; ++j)
		{
			NL[i * maxNeighbors + j] = (i + j + 3) % nAtoms;
		}
	}
}
//
// void result_check()
//{
//  int i, j;
//
//  for (i = 0; i < array_add_N; i++)
//  {
//    if (conv2d_2x2_C[i] != D[i]) printf("There is an error in location (%d)[%d, %d]\n", i, conv2d_2x2_C[i], D[i]);
//  }
//}

int main(int argc, char **argv)
{
	long long unsigned start;
	long long unsigned end;
	volatile int result;
	init_array();
	printf("Initialization finished!\n");

//	start = rdcycle();
//	/* Run kernels. */
//	conv2d_3x3();
//	fir();
//	pedometer();
//	stencil2d();
//	gemm();
//	fft4();
//	md();
//	end = rdcycle();
//	printf("It takes %d cycles for CPU to finish the task.\n", end - start);

	start = rdcycle();

	void *conv2d_3x3_cgra_din_addr[9] = {conv2d_3x3_A, conv2d_3x3_A, conv2d_3x3_A, conv2d_3x3_A, conv2d_3x3_A, conv2d_3x3_A, conv2d_3x3_A, conv2d_3x3_A, conv2d_3x3_A};
	void *conv2d_3x3_cgra_dout_addr[1] = {(void *)conv2d_3x3_B + 128};
	conv2d_3x3_cgra_execute(conv2d_3x3_cgra_din_addr, conv2d_3x3_cgra_dout_addr);
//	  result = fence(1);

	void *fir_cgra_din_addr[8] = {coefficients, coefficients, coefficients, coefficients, fir_input, fir_input, fir_input, fir_input};
	void *fir_cgra_dout_addr[1] = {(void*)fir_output+16};
	fir_cgra_execute(fir_cgra_din_addr, fir_cgra_dout_addr);
//	  result = fence(1);

	void *pedometer_cgra_din_addr[6] = {acc_avg_x, acc_avg_y, acc_avg_z, acceleration_x, acceleration_y, acceleration_z};
	void *pedometer_cgra_dout_addr[1] = {acc_vector};
	pedometer_cgra_execute(pedometer_cgra_din_addr, pedometer_cgra_dout_addr);
//	  result = fence(1);

	void *stencil2d_cgra_din_addr[6] = {filter, filter, filter, orig, orig, orig};
	void *stencil2d_cgra_dout_addr[1] = {sol};
	stencil2d_cgra_execute(stencil2d_cgra_din_addr, stencil2d_cgra_dout_addr);
//	  result = fence(1);

	void *gemm_cgra_din_addr[8] = {gemm_m1, gemm_m1, gemm_m1, gemm_m1, gemm_m2, gemm_m2, gemm_m2, gemm_m2};
	void *gemm_cgra_dout_addr[1] = {gemm_prod};
	gemm_cgra_execute(gemm_cgra_din_addr, gemm_cgra_dout_addr);
//	  result = fence(1);

	void *fft_cgra_din_addr[8] = {XI0, XI1, XI2, XI3, XR0, XR1, XR2, XR3};
	void *fft_cgra_dout_addr[8] = {YR0, YI0, YR1, YI1, YR2, YI2, YR3, YI3};
	fft_cgra_execute(fft_cgra_din_addr, fft_cgra_dout_addr);
//	  result = fence(1);

	void *knn_cgra_din_addr[7] = {NL, position_x, position_x, position_z, position_z, position_y, position_y};
	void *knn_cgra_dout_addr[3] = {force_x, force_y, force_z};
	knn_cgra_execute(knn_cgra_din_addr, knn_cgra_dout_addr);
	result = fence(1);

	end = rdcycle();
	printf("It takes %d cycles for CGRA to finish the task(%d).\n", end - start, result);

	//  result_check();
	printf("Done!\n");

	return 0;
}